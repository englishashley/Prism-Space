import numpy as np
import random
import matplotlib.pyplot as plt

################################################################################
# SIMPLIFIED RADIATION MODEL
################################################################################

# Material properties: approximate stopping power for protons/electrons, densities
# "LET" is a stand-in for effective attenuation in an exponential model
# These numbers are simplified placeholders, not official NASA data.
MATERIALS = {
    "Aluminum":      {"density": 2.7,  "LET": 1.5},
    "Tungsten":      {"density": 19.3, "LET": 4.0},
    "BoronPolymer":  {"density": 1.2,  "LET": 3.0},
    "Copper":        {"density": 8.96, "LET": 3.5}
}

# Example “incident flux” representing a mix of 1-100 MeV protons
ENERGY_LEVELS = np.linspace(1, 100, 100)  # Changed to 1-100 MeV

# Different incident fluxes for TID, GCRs, and SPEs
INCIDENT_FLUX_TID = np.exp(-ENERGY_LEVELS / 50)  # Simple decaying spectrum for TID
INCIDENT_FLUX_GCR = np.exp(-ENERGY_LEVELS / 30)  # Different spectrum for GCRs
INCIDENT_FLUX_SPE = np.exp(-ENERGY_LEVELS / 10)  # Different spectrum for SPEs

# Equivalent exposure values for SSO environments (in krads/year)
EQUIVALENT_DOSE_TID = 30  # Example value for TID in SSO
EQUIVALENT_DOSE_GCR = 10  # Example value for GCRs in SSO
EQUIVALENT_DOSE_SPE = 20  # Example value for SPEs in SSO

def attenuation_factor(material, thickness_cm):
    """
    Return exponential attenuation factor e^(-LET*density*thickness) 
    for a given material and thickness in cm.
    """
    props = MATERIALS[material]
    stopping_power = props["LET"] * props["density"]  # Simplified
    return np.exp(-stopping_power * thickness_cm)

def compute_transmitted_flux(layers, energy_levels, incident_flux):
    """
    Compute the final transmitted flux after passing through each layer in 'layers'.
    Each layer is a tuple: (material_name, thickness_in_cm).
    """
    flux = np.copy(incident_flux)
    for mat, thick in layers:
        att = attenuation_factor(mat, thick)
        flux *= att  # multiply flux by attenuation factor
    return flux

MISSION_DURATION_YEARS = 5  # 5-year mission

def compute_secondary_particles(layers):
    """
    Compute the secondary particles generated by high-Z materials and mitigate them using boron-poly materials.
    """
    secondary_particles = 0
    for mat, thick in layers:
        if mat == "Tungsten":
            # Assume secondary particles are proportional to thickness of high-Z material
            secondary_particles += thick * 0.1  # Example factor for secondary particles
    return secondary_particles

def compute_total_dose(layers, incident_flux, equivalent_dose):
    """
    Approximate the 'dose' by integrating the final flux over the energy range.
    Lower is better. This is our 'fitness' function to minimize.
    """
    transmitted = compute_transmitted_flux(layers, ENERGY_LEVELS, incident_flux)
    # Simple integral of flux as a stand-in for dose
    total_dose = np.trapezoid(transmitted, x=ENERGY_LEVELS)
    # Scale the dose to the equivalent exposure value
    total_dose_krads = total_dose * equivalent_dose
    # Add secondary particles dose
    secondary_particles = compute_secondary_particles(layers)
    total_dose_krads += secondary_particles
    return total_dose_krads

def compute_total_mass(layers, area=1.0):
    """
    Estimate mass in kg for a given set of layers over a given area (default=1 m^2).
    mass = density * thickness (cm) * area (m^2) * 10, because 1 cm thickness over 1 m^2 
    is 0.01 m * 1 m^2 = 0.01 m^3, and density is in g/cm^3 => conversion factor ~10 
    to get kg.
    """
    mass_kg = 0.0
    for mat, thick_cm in layers:
        dens = MATERIALS[mat]["density"]  # g/cm^3
        volume_cm3 = area * (thick_cm * 10000.0)  # 1 m^2 => 10000 cm^2
        # mass in grams
        mass_g = dens * volume_cm3
        # convert grams to kg
        mass_kg_layer = mass_g / 1000.0
        mass_kg += mass_kg_layer
    return mass_kg

################################################################################
# GENETIC ALGORITHM
################################################################################

# Let's define the 'genes' for each layer: (material_index, thickness_in_cm)
# We'll allow certain materials in certain layers, or let the GA pick from a set.

MATERIAL_OPTIONS = ["Aluminum", "Tungsten", "BoronPolymer", "Copper"]
NUM_LAYERS = 5  # e.g., we want 5 layers total

# Constraints
MIN_THICKNESS = 0.01  # cm
MAX_THICKNESS = 1   # cm

POP_SIZE = 100  # Increased population size
NUM_GENERATIONS = 1000  # Number of generations remains the same
MUTATION_RATE = 0.2  # Increased mutation rate
ELITE_SIZE = 8

def random_individual():
    """
    Create a random 'individual' representing a layering solution.
    Each layer is (material_index, thickness).
    """
    individual = []
    for _ in range(NUM_LAYERS - 1):  # Create all layers except the last one
        mat_idx = np.random.randint(len(MATERIAL_OPTIONS))
        thickness = np.random.uniform(MIN_THICKNESS, MAX_THICKNESS)
        individual.append((mat_idx, thickness))
    # Ensure the last layer is always Aluminum
    aluminum_idx = MATERIAL_OPTIONS.index("Aluminum")
    thickness = np.random.uniform(MIN_THICKNESS, MAX_THICKNESS)
    individual.append((aluminum_idx, thickness))
    return individual

def combine_layers(layers):
    """
    Combine layers of the same material if they are stacked on top of each other.
    """
    combined_layers = []
    for mat, thick in layers:
        if combined_layers and combined_layers[-1][0] == mat:
            combined_layers[-1] = (mat, combined_layers[-1][1] + thick)
        else:
            combined_layers.append((mat, thick))
    return combined_layers

def high_low_high_layering(layers):
    """
    Ensure high-low-high Z-layering strategy for better radiation shielding.
    """
    high_z_materials = ["Tungsten", "Copper"]
    low_z_materials = ["Aluminum", "BoronPolymer"]
    
    # Ensure the first and last layers are high-Z materials
    if len(layers) > 1:
        if layers[0][0] not in high_z_materials:
            layers[0] = ("Tungsten", layers[0][1])
        if layers[-2][0] not in high_z_materials:  # Ensure the second last layer is high-Z
            layers[-2] = ("Tungsten", layers[-2][1])
    
    # Ensure the middle layers are low-Z materials, favoring BoronPolymer
    for i in range(1, len(layers) - 2):
        if layers[i][0] not in low_z_materials or layers[i][0] != "BoronPolymer":
            layers[i] = ("BoronPolymer", layers[i][1])
    
    return layers

def decode_individual(individual):
    """
    Convert from (material_index, thickness) to actual (material_name, thickness).
    Ensure the last layer is always at least 1mm of Aluminum.
    """
    layers = []
    for mat_idx, thick in individual[:-1]:  # Decode all layers except the last one
        mat_name = MATERIAL_OPTIONS[mat_idx]
        layers.append((mat_name, thick))
    # Ensure the last layer is always at least 1mm of Aluminum
    layers.append(("Aluminum", max(individual[-1][1], 0.1)))  # 0.1 cm = 1 mm
    # Combine layers of the same material
    combined_layers = combine_layers(layers)
    # Apply high-low-high Z-layering strategy
    return high_low_high_layering(combined_layers)

TARGET_WEIGHT_KG = 10  # Target weight in kg

def fitness(individual):
    """
    Fitness function to prioritize minimizing weight while ensuring radiation protection.
    We'll combine total_dose and mass: alpha*(mass) + total_dose.
    Lower is better.
    """
    layers = decode_individual(individual)
    dose_tid = compute_total_dose(layers, INCIDENT_FLUX_TID, EQUIVALENT_DOSE_TID)
    dose_gcr = compute_total_dose(layers, INCIDENT_FLUX_GCR, EQUIVALENT_DOSE_GCR)
    dose_spe = compute_total_dose(layers, INCIDENT_FLUX_SPE, EQUIVALENT_DOSE_SPE)
    total_dose = dose_tid + dose_gcr + dose_spe  # Sum of all doses
    mass = compute_total_mass(layers, area=1.0)  # 1 m^2
    alpha = 2.0  # Higher weighting factor for mass penalty to prioritize minimizing weight
    return alpha * mass + total_dose

def crossover(parent1, parent2):
    """
    Single-point crossover. We'll randomly pick a cut point in the layer list.
    """
    cut = np.random.randint(1, NUM_LAYERS)
    child1 = parent1[:cut] + parent2[cut:]
    child2 = parent2[:cut] + parent1[cut:]
    return child1, child2

def mutate(individual):
    """
    Randomly mutate layer thickness or material index.
    """
    for i in range(len(individual)):  # Include the last layer
        if np.random.rand() < MUTATION_RATE:
            # random change in material or thickness
            if np.random.rand() < 0.5:
                # mutate material
                individual[i] = (np.random.randint(len(MATERIAL_OPTIONS)), individual[i][1])
            else:
                # mutate thickness
                new_thick = np.random.uniform(MIN_THICKNESS, MAX_THICKNESS)
                individual[i] = (individual[i][0], new_thick)
    return individual

def tournament_selection(pop, k=3):
    """
    Tournament selection: pick k individuals, return the best.
    """
    selected = random.sample(pop, k)
    best = min(selected, key=lambda ind: fitness(ind))
    return best

def rotate_layers(individual):
    """
    Rotate the layers of the individual to create a new configuration.
    """
    rotated_individual = individual[1:] + individual[:1]
    return rotated_individual

def pareto_front(population):
    """
    Identify the Pareto front in the population.
    """
    pareto_front = []
    for individual in population:
        dominated = False
        for other in population:
            if (fitness(other) < fitness(individual) and
                compute_total_mass(decode_individual(other)) <= compute_total_mass(decode_individual(individual))):
                dominated = True
                break
        if not dominated:
            pareto_front.append(individual)
    return pareto_front

def genetic_algorithm():
    # Initialize population
    population = [random_individual() for _ in range(POP_SIZE)]
    
    best_fitness_evolution = []
    best_fitness = float('inf')
    generations_without_improvement = 0
    max_generations_without_improvement = 50  # Stopping criterion
    
    for gen in range(NUM_GENERATIONS):
        # Evaluate fitness
        pop_sorted = sorted(population, key=lambda ind: fitness(ind))
        best_individual = pop_sorted[0]
        best_fit = fitness(best_individual)
        best_fitness_evolution.append(best_fit)
        
        # Check for improvement
        if best_fit < best_fitness:
            best_fitness = best_fit
            generations_without_improvement = 0
        else:
            generations_without_improvement += 1
        
        # Check stopping criterion
        if generations_without_improvement >= max_generations_without_improvement:
            print(f"Converged after {gen} generations.")
            break
        
        # Elitism: keep the top N
        new_population = pop_sorted[:ELITE_SIZE]
        
        # Fill the rest of population
        while len(new_population) < POP_SIZE:
            # select parents
            parent1 = tournament_selection(pop_sorted)
            parent2 = tournament_selection(pop_sorted)
            # crossover
            child1, child2 = crossover(parent1, parent2)
            # mutate
            child1 = mutate(child1)
            child2 = mutate(child2)
            new_population.append(child1)
            if len(new_population) < POP_SIZE:
                new_population.append(child2)
        
        # Rotate layers for additional configurations
        for i in range(len(new_population)):
            if np.random.rand() < 0.5:  # 50% chance to rotate
                new_population[i] = rotate_layers(new_population[i])
        
        population = new_population
        
        if gen % 5 == 0:
            print(f"Generation {gen}: Best Fitness = {best_fit:.4f}")
    
    # final best
    pop_sorted = sorted(population, key=lambda ind: fitness(ind))
    best_ind = pop_sorted[0]
    return best_ind, best_fitness_evolution

def estimate_radiation_behind_shielding(layers):
    """
    Estimate the radiation seen by the electronics behind the shielding.
    """
    dose_tid = compute_total_dose(layers, INCIDENT_FLUX_TID, EQUIVALENT_DOSE_TID)
    dose_gcr = compute_total_dose(layers, INCIDENT_FLUX_GCR, EQUIVALENT_DOSE_GCR)
    dose_spe = compute_total_dose(layers, INCIDENT_FLUX_SPE, EQUIVALENT_DOSE_SPE)
    total_dose = dose_tid + dose_gcr + dose_spe  # Sum of all doses
    return total_dose

def run_multiple_ga_runs(num_runs=100):
    """
    Run the genetic algorithm multiple times and compare the end solutions to find the best one.
    """
    best_solutions = []
    best_fit_histories = []
    for run in range(num_runs):
        print(f"\n=== Running GA iteration {run+1}/{num_runs} ===")
        best_solution, fit_history = genetic_algorithm()
        best_solutions.append((best_solution, fitness(best_solution)))
        best_fit_histories.append(fit_history)
    
    # Find the best solution among all runs
    best_solution_overall = min(best_solutions, key=lambda x: x[1])[0]
    best_fit_history_overall = best_fit_histories[best_solutions.index(min(best_solutions, key=lambda x: x[1]))]
    return best_solution_overall, best_fit_history_overall

################################################################################
# RUN THE GA
################################################################################

if __name__ == "__main__":
    num_runs = 100  # Number of GA runs
    best_solution_overall, best_fit_history = run_multiple_ga_runs(num_runs)
    
    # Decode the best layering
    best_layers = decode_individual(best_solution_overall)
    
    # Evaluate final performance for each type of radiation
    final_dose_tid = compute_total_dose(best_layers, INCIDENT_FLUX_TID, EQUIVALENT_DOSE_TID)
    final_dose_gcr = compute_total_dose(best_layers, INCIDENT_FLUX_GCR, EQUIVALENT_DOSE_GCR)
    final_dose_spe = compute_total_dose(best_layers, INCIDENT_FLUX_SPE, EQUIVALENT_DOSE_SPE)
    final_mass = compute_total_mass(best_layers, area=1.0)  # for 1 m^2 area
    
    # Estimate radiation seen by the electronics
    estimated_radiation = estimate_radiation_behind_shielding(best_layers)
    
    print("\n=== BEST LAYER CONFIGURATION FOUND ===")
    for i, (mat, thick) in enumerate(best_layers):
        print(f"Layer {i+1}: {mat} @ {thick*10:.2f} mm")
    print(f"Approx. Final Dose TID (krads) for 5 years: {final_dose_tid:.4f}")
    print(f"Approx. Final Dose GCR (krads) for 5 years: {final_dose_gcr:.4f}")
    print(f"Approx. Final Dose SPE (krads) for 5 years: {final_dose_spe:.4f}")
    print(f"Approx. Shield Mass (1 m^2 area): {final_mass:.2f} kg\n")
    print(f"Estimated Radiation Seen by Electronics (krads) for 5 years: {estimated_radiation:.4f}")
    
    # Plot fitness evolution of the best run
    plt.figure()
    plt.plot(best_fit_history, '-o', label="Best Fitness Each Generation")
    plt.xlabel("Generation")
    plt.ylabel("Fitness (alpha*Mass + Dose)")
    plt.title("GA Optimization of Multi-Layer Shielding")
    plt.grid()
    plt.legend()
    plt.show()
